#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "cache.h"

#ifndef SIGNAL_H
#define SIGNAL_H

/*MSI and MESI Signals:
P_WR: Processor Write
P_RD: Processor Read
B_WR: Bus Write
B_RD: Bus Read

Additional MESI Signals:
P_Writeback:= Processor Write Back to Memory

MSI Diagram directions:
I (P_WR) -> M
I (P_RD) -> S
M (P_RD or P_WR) -> M
M (B_WR) -> I
M (B_RD) -> S
S (P_RD) -> S
S (P_WR) -> M
S (B_RD) -> S
S (B_WR) -> I

MESI Diagram directions:
I (P_WR) -> M
I (P_RD) -> S
I (P_RD) -> E
M (P_RD or P_WR) -> M
M (P_Writeback or B_WR) -> I
M (B_RD) -> S
S (P_RD) -> S
S (P_WR) -> M
S (B_WR) -> I
S (B_RD) -> S
E (P_RD) -> E
E (P_WR) -> M
E (B_WR) -> I
E (B_RD) -> S*/

typedef enum {P_WR = 0, P_RD = 1, B_WR = 2, B_RD = 3, P_Writeback = 4, NA = 5} signal_t;

extern const char* signalNames[];
typedef enum {Read = 82, Write = 87} access_type_t;

struct input_line_info
{
    int processor;
    int block_access;
    int access_time;
    char access_type;
};

//the below structure is instantiated for just one core and one memory location in one time stamp and reset at every time stamp, this is to be used for status/signal information going into the protocol functions
struct per_time_stats
{
    status_t prev_status;
    signal_t curr_signal;
    status_t new_status;
    int mem_location;
};

//the below structure is instantiated for just one memory location in one time stamp and reset at every time stamp, this is to be used for status/signal information going into the protocol functions
struct per_core_stats {
    struct per_time_stats core0;
    struct per_time_stats core1;
    struct per_time_stats core2;
    struct per_time_stats core3;
};

static const struct per_core_stats resetStruct = {
    {Uninit, NA, Uninit, 0},
    {Uninit, NA, Uninit, 0},
    {Uninit, NA, Uninit, 0},
    {Uninit, NA, Uninit, 0}
};

//keeping an array of parsed input data, fill one array slot by calling the inputParse function
//can change the array size and the usage as needed if we want to take in more than one thing at a time
//I didn't want to bring everything in from the input file because we don't know how many lines we will have in the input file
//and therefore won't necessarily know how large the array needs to be
struct input_line_info arr_input[1];

//Use this function in each core in order to get the signals generated by each input for each cache
//outputs: *output signal -> this is the bus or processor read or write signal generated for each core
//outputs: *previous signal -> this is the location mem MESI/MSI/MI status before current time
//outputs from this function pass to a MESI/MSI/MI function in order to figure out the next status of this locatiom mem in each cache
void inputSignals(signal_t *output_signal, status_t *previous_status, int processor_num, int current_processor,struct DLLNode **current_processor_cache, int location_mem, access_type_t input_access_type);

//Use this function in order to pull in data from the input file -> one row at a time with current implementation
void inputParse(struct input_line_info *line_info, FILE *file);

//Use this function to find out how many rows of inputs we have in our input file
int inputLength(char *filepath);

//Use this function to find the max of four integers
int maxFour(int a, int b, int c, int d);

//Use this function in order to know how much time should be tasked for particular cache/memory activities
int timetax(struct per_core_stats currentStats, int processor_num);

//other notes:
//when we do a read, insert that mem location into cache and update status
//when we have a write, it's essentially in our code acts as a read, we imagine that we pulled the data into the cache (read) if it wasn't there already and update the statuses (aka cache insert)
//overall use gettime in order to run analysis on the performance of the protocol and use the input access time to step through the time

#endif